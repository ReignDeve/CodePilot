{"text":"Ein paar Punkte, die dir auffallen könnten:\nSchleifenbedingung\nAktuell „i <= nums.Length“ – das führt beim letzten Durchlauf zu „i == nums.Length“ und damit zu einem IndexOutOfRange, weil gültige Indizes von 0 bis nums.Length–1 gehen.\nDenk mal drüber nach, welche Bedingung hier passen müsste.\nRückgabewert\nDeine Methode liefert kein Ergebnis zurück. Überleg dir, wo du das neu befüllte Array wieder rausgeben musst.\nMit diesen beiden Hinweisen solltest du dein IncrementArray zum Laufen bringen können."}
{"text":"Hier ein paar Hinweise, worauf du achten kannst:\nSchleifenbedingung\nDu läufst von 0 bis nums.Length inklusive („<=“). Da Arrays aber von 0 bis nums.Length-1 indiziert sind, führt das bei i == nums.Length zu einem IndexOutOfRange.\nÜberlege dir, welche Bedingung du stattdessen brauchst.\nRückgabewert\nDeine Methode liefert derzeit nichts zurück. Schau dir den Methoden–Rückgabetyp int[] an und überlege, was noch fehlt, damit der Compiler zufrieden ist.\nMit diesen beiden Punkten solltest du den Code korrigieren können."}
{"text":"Hier nur ein paar Denkanstöße, ohne die komplette Lösung vorzugeben:\nSchleifenbedingung prüfen\nIn C# läuft ein Array von Index 0 bis Length – 1. Mit i <= nums.Length greifst du beim letzten Durchlauf auf nums[nums.Length] zu – das wirft eine IndexOutOfRangeException. Überleg dir, welche Vergleichsoperation hier richtig ist.\nRückgabewert nicht vergessen\nDeine Methode deklariert einen Rückgabewert int[], liefert aber am Ende nichts zurück. Wo und was musst du am Schluss der Methode noch einfügen?\nViel Erfolg beim Anpassen!"}
{"text":"Ein, zwei Kleinigkeiten, auf die du noch achten solltest:\nSchleifenbedingung\nDu verwendest for (int i = 0; i <= nums.Length; i++)\nAber gültige Indizes in einem Array gehen nur von 0 bis nums.Length – 1. Mit <= liegst du also beim letzten Durchlauf außerhalb des Arrays. Besser: i < nums.Length.\nRückgabewert\nAm Ende deiner Methode fehlt return result;. Ohne Rückgabe gibt’s einen Kompilierfehler, weil deine Signatur int[] als Rückgabetyp verlangt.\nWenn du diese beiden Punkte anpasst, sollte dein Code wie gewünscht arbeiten. Viel Erfolg beim Ausprobieren!"}
{"text":"Ein paar Hinweise, damit’s läuft:\nSchleifenbedingung\nDu nutzt i <= nums.Length. Da Arrays in C# 0-basiert sind, ist der höchste Index nums.Length - 1. Mit <= versuchst du einmal zu viel auf nums[nums.Length] zuzugreifen. Lieber for (int i = 0; i < nums.Length; i++) { … }\nRückgabe\nDeine Methode baut das resultArray auf, gibt es aber am Ende gar nicht zurück. Denk an return result;\nDrüber hinaus ist die Logik an sich korrekt: Für jeden Index nimmst du nums[i] + 1 und schreibst es in result[i]."}
