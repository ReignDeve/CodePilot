[
  {
    "uid": "for-loop-arrays",
    "status": "NotStarted",
    "title": "1. For Loop with Arrays",
    "difficulty": "Easy",
    "solution": "Use a standard for loop to iterate and push items.",
    "code": "public int[] IncrementArray(int[] nums) {\n    // TODO: implement increment logic\n}",
    "description": "Given an array of numbers, return a new array where each element is incremented by 1.\n\nYou may assume:\n- The input array nums contains at least one element.\n\nExample 1\nInput: nums = [1, 2, 3]\nOutput: [2, 3, 4]\n\nExample 2\nInput: nums = [0, -1, -2]\nOutput: [1, 0, -1]\n\nExample 3\nInput: nums = [5]\nOutput: [6]\n\nConstraints:\n- 1 ≤ nums.length ≤ 10⁴\n- -10⁹ ≤ nums[i] ≤ 10⁹",
    "invocations": [ "new[]{1, 2, 3}", "new[]{0, -1, -2}", "new[]{5}" ]
  },
  {
    "uid": "filter-array-elements",
    "status": "NotStarted",
    "title": "2. Filter Array Elements",
    "difficulty": "Medium",
    "solution": "Use Array.filter() with a condition function.",
    "code": "public int[] FilterArray(int[] nums, string criterion, int x = 0, int A = 0, int B = 0) {\n    // TODO: implement filter logic based on criterion\n}",
    "description": "Given an array of integers nums and a filter criterion, return a new array containing only those elements that satisfy the criterion.\n\nYou may assume:\n- The input array nums contains at least one element.\n- Exactly one of the following criteria is specified per call:\n  1. \"even\" numbers\n  2. Greater than a given value x\n  3. Within an inclusive range [A, B]\n\nYou must not modify the order of elements, and you may use each element only once.\n\nExample 1\nInput: nums = [3, 12, 7, 20, 5, 8, 33], criterion = \"even\"\nOutput: [12, 20, 8]\n\nExample 2\nInput: nums = [3, 12, 7, 20, 5, 8, 33], criterion = \"greater\", x = 10\nOutput: [12, 20, 33]\n\nExample 3\nInput: nums = [3, 12, 7, 20, 5, 8, 33], criterion = \"range\", A = 7, B = 20\nOutput: [7, 12, 20, 8]\n\nConstraints:\n- 1 ≤ nums.length ≤ 10⁴\n- -10⁹ ≤ nums[i], x, A, B ≤ 10⁹",
    "invocations": [
      "new[]{3, 12, 7, 20, 5, 8, 33}, \"even\"",
      "new[]{3, 12, 7, 20, 5, 8, 33}, \"greater\", 10",
      "new[]{3, 12, 7, 20, 5, 8, 33}, \"range\", 0, 7, 20"
    ]
  },
  {
    "uid": "reduce-array-to-single-value",
    "status": "NotStarted",
    "title": "4. Reduce Array to Single Value",
    "difficulty": "Hard",
    "solution": "Use Array.reduce() with accumulator logic.",
    "code": "public int SumArray(int[] nums) {\n    // TODO: implement summation logic\n}",
    "description": "Given an array of numbers, return the sum of all elements using reduce.\n\nYou may assume:\n- The input array contains at least one number.\n\nExample 1\nInput: nums = [5, 10, 15]\nOutput: 30\n\nExample 2\nInput: nums = [1, 1, 1, 1]\nOutput: 4\n\nExample 3\nInput: nums = [-5, 5]\nOutput: 0\n\nConstraints:\n- 1 ≤ nums.length ≤ 10⁴\n- -10⁹ ≤ nums[i] ≤ 10⁹",
    "invocations": [ "new[]{5, 10, 15}", "new[]{1, 1, 1, 1}", "new[]{-5, 5}" ]
  },
  {
    "uid": "maximum-gap",
    "status": "NotStarted",
    "title": "2. Maximum Successive Difference",
    "difficulty": "Hard",
    "solution": "Use a bucket-based approach (Pigeonhole principle): compute global min/max, choose bucket size = ceil((max-min)/(n-1)), place each number into a bucket tracking only min/max per bucket, then scan buckets to find the largest gap between consecutive non-empty buckets.",
    "code": "public int MaximumGap(int[] nums) {\n if (nums == null || nums.Length < 2) return 0;\n\n int n = nums.Length;\n int minVal = int.MaxValue, maxVal = int.MinValue;\n foreach (var x in nums) {\n if (x < minVal) minVal = x;\n if (x > maxVal) maxVal = x;\n }\n if (minVal == maxVal) return 0; // all elements equal\n\n // Bucket size and count (use ceiling for size)\n int bucketSize = (int)Math.Ceiling((double)(maxVal - minVal) / (n - 1));\n int bucketCount = (maxVal - minVal) / bucketSize + 1;\n\n int[] bucketMin = new int[bucketCount];\n int[] bucketMax = new int[bucketCount];\n bool[] used = new bool[bucketCount];\n\n for (int i = 0; i < bucketCount; i++) {\n bucketMin[i] = int.MaxValue;\n bucketMax[i] = int.MinValue;\n }\n\n // Place numbers into buckets (track only min/max per bucket)\n foreach (var x in nums) {\n int idx = (x - minVal) / bucketSize;\n if (!used[idx]) {\n bucketMin[idx] = x;\n bucketMax[idx] = x;\n used[idx] = true;\n } else {\n if (x < bucketMin[idx]) bucketMin[idx] = x;\n if (x > bucketMax[idx]) bucketMax[idx] = x;\n }\n }\n\n // Scan buckets to find max gap between consecutive non-empty buckets\n int prevMax = minVal;\n int maxGap = 0;\n for (int i = 0; i < bucketCount; i++) {\n if (!used[i]) continue;\n maxGap = Math.Max(maxGap, bucketMin[i] - prevMax);\n prevMax = bucketMax[i];\n }\n\n return maxGap;\n}",
    "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains fewer than two elements, return 0.\n\nYou must write an algorithm that runs in linear time and uses linear extra space.\n\nExample 1\nInput: nums = [3, 6, 9, 1]\nOutput: 3\nExplanation: The sorted form of the array is [1, 3, 6, 9]; either (3, 6) or (6, 9) has the maximum difference 3.\n\nExample 2\nInput: nums = [10]\nOutput: 0\nExplanation: The array contains fewer than 2 elements, therefore return 0.\n\nConstraints:\n- 1 ≤ nums.length ≤ 10^5\n- 0 ≤ nums[i] ≤ 10^9",
    "invocations": [
      "new[]{3, 6, 9, 1}",
      "new[]{10}",
      "new[]{1, 10000000, 5, 7}"
    ]
  }
]
